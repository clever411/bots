#ifndef CLEVER_EXTRACTORS_HPP
#define CLEVER_EXTRACTORS_HPP

#include <functional>
#include <stack>
#include <string>

namespace clever {
	template<typename T = void>
	struct State {
		enum {
			failbit = 1 << 0,
			eofbit = 1 << 1,
			badbit = 1 << 2,
			badbracketbit = 1 << 3,
			badsymbolbit = 1 << 4
		};
		void setstate(int additionstate) {
			_state = _state|additionstate;
		}
		void clear() {
			_state = 0;
		}
		void clear(int newstate) {
			_state = newstate;
		}
		int state() {
			return _state;
		}

		inline operator bool() {
			return good();
		}
		inline bool good() const {
			return !_state;
		}
		inline bool fail() const {
			return (_state&failbit) || (_state&badbit);
		}
		inline bool bad() const {
			return _state&badbit;
		}
		inline bool eof() const {
			return _state&eofbit;
		}

	private:
		int _state = 0;
	};


	template<typename Iterator> struct BracketsExtracter: State<> {
		BracketsExtracter(): firstbracket('\0') {}
		BracketsExtracter(Iterator b, Iterator e, char firstbracket): firstbracket(firstbracket) {
			operator()(b, e);
		}
		std::string operator()(Iterator b, Iterator e) {
			current = b;
			end = e;
			result = "";
			clear();
			std::string::size_type brpos = brackets.find(firstbracket);
			if(brpos == std::string::npos || brpos%2 == 1) {
				setstate(badbracketbit|failbit);
				return result;
			}
			std::stack<char> stackbrackets;
			stackbrackets.push(firstbracket);
			char ch;
			while(current != e) {
				ch = *current;
				brpos = brackets.find(ch);
				if(brpos != std::string::npos) {
					if(brpos % 2 == 0) {
						stackbrackets.push(ch);
					}
					else if(!stackbrackets.empty() && (stackbrackets.top() == brackets.at(brpos-1))) {
						stackbrackets.pop();
						if(stackbrackets.empty()) {
							return result;
						}
					}
					else {
						setstate(badbracketbit|failbit);
						return result;
					}
				}
				result.push_back(ch);
				++current;
			}
			setstate(failbit|eofbit);
			return "";
		}
		std::string operator()(Iterator b, Iterator e, char bracket) {
			firstbracket = bracket;
			return operator()(b, e);
		}

		Iterator current;
		Iterator end;
		char firstbracket;
		std::string result;

		std::string brackets = "()<>[]{}";
	};

	template<typename Iterator> struct BracketsExtracterUntil: State<> {
		BracketsExtracterUntil() {}
		BracketsExtracterUntil(Iterator b, Iterator e, std::string const &until): until(until) {
			operator()(b, e);
		}

		std::string operator()(Iterator b, Iterator e) {
			current = b;
			end = e;
			result = "";
			clear();
			char ch;
			BracketsExtracter<Iterator> bex;
			bex.brackets = brackets;
			while(current != end) {
				ch = *current;
				if(until.find(ch) != std::string::npos) {
					return result;
				}
				if(brackets.find(ch) != std::string::npos) {
					result.push_back(ch);
					++current;
					result += bex(current, end, ch);
					current = bex.current;
					if(!bex) {
						setstate(bex.state());
						return result;
					}
					ch = *current;
				}
				result.push_back(ch);
				++current;
			}
			setstate(failbit|eofbit);
			return result;
		}
		std::string operator()(Iterator b, Iterator e, std::string const &newuntil) {
			until = newuntil;
			return operator()(b, e);
		}

		Iterator current;
		Iterator end;
		std::string until;
		std::string result;

		std::string brackets = "()<>[]{}";
	} ;


	template<typename Iterator> struct NameExtracter: State<> {
		NameExtracter() {}
		NameExtracter(Iterator b, Iterator e) {
			operator()(b, e);
		}
		std::string operator()(Iterator b, Iterator e) {
			current = b;
			end = e;
			result = "";
			clear();
			if(current == end) {
				setstate(failbit|eofbit);
				return result;
			}
			char ch = *current;
			if(!first_symbol_is_good(ch)) {
				setstate(failbit|badsymbolbit);
				return result;
			}
			result.push_back(ch);
			++current;
			while(current != end) {
				ch = *current;
				if(symbol_is_good(ch))
					result.push_back(ch);
				else {
					return result;
				}
				++current;
			}
			setstate(failbit|eofbit);
			return result;
		}

		Iterator current;
		Iterator end;
		std::string result;

		std::function<bool(char)> first_symbol_is_good = [](char ch)->bool { return std::isalpha(ch) || ch == '_'; };
		std::function<bool(char)> symbol_is_good = [](char ch)->bool { return std::isalpha(ch) || std::isdigit(ch) || ch == '_'; };

	};

	template<typename Iterator> struct SymbolsExtracter: State<> {
		SymbolsExtracter() {}
		SymbolsExtracter(Iterator b, Iterator e, std::string const &symbols): symbols(symbols) {
			operator()(b, e);
		}
		std::string operator()(Iterator b, Iterator e) {
			current = b;
			end = e;
			result = "";
			clear();
			char ch;
			while(current != end) {
				ch = *current;
				if(symbols.find(ch) == std::string::npos) {
					return result;
				}
				result.push_back(ch);
				++current;
			}
			setstate(failbit|eofbit);
			return result;
		}
		std::string operator()(Iterator b, Iterator e, std::string const &newsymbols) {
			symbols = newsymbols;
			return operator()(b, e);
		}

		Iterator current;
		Iterator end;

		std::string result;
		std::string symbols;
	};


	template<typename Iterator> struct SymbolsDeleter {
	public:
		SymbolsDeleter() {}
		SymbolsDeleter(std::string const &tocorrect, std::string const &todelete): result(tocorrect), todelete(todelete) {
			operator()();
		}

		std::string operator()() {
			result = "";
			std::string::size_type posbuf;
			for(; current != end; ++current) {
				posbuf = todelete.find(*current);
				if(posbuf != std::string::npos)
					todelete.erase(todelete.begin()+posbuf);
				else
					result.push_back(*current);
			}
			return result;
		}
		std::string operator()(std::string const &newtocorrect, std::string const &newtodelete) {
			current = newtocorrect.begin();
			end = newtocorrect.end();
			todelete = newtodelete;
			return operator()();
		}
		std::string operator()(Iterator b, Iterator e) {
			current = b;
			end = e;
			return operator()();
		}
		std::string operator()(Iterator b, Iterator e, std::string const &newtodelete) {
			todelete = newtodelete;
			current = b;
			end = e;
			return operator()();
		}

		Iterator current;
		Iterator end;

		std::string result;
		std::string todelete;
	};
}

#endif // CLEVER_EXTRACTORS_HPP
